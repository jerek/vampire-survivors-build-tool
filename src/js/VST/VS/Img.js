/**
 * Displays images using the game's JSON & PNG files.
 */
VST.VS.Img = new function () {
    const self = this;
    const DOM = VST.DOM;
    const Util = VST.Util;
    const VS = VST.VS;

    // *********************** //
    // ***** DEFINITIONS ***** //
    // *********************** //

    /**
     * @typedef {Object} TexturePacker3Data A complete Vampire Survivors JSON file, as generated by TexturePacker 3.0.
     * @property {Tp3Sprite[]} textures The sprite texture data.
     * @property {Object}      meta     Some information about the TexturePacker version that was used.
     */

    /**
     * @typedef {Object} Tp3Frame Texture Packer 3 data describing an individual image.
     * @property {string}     filename         The pre-sprite filename.
     * @property {false}      rotated          This appears to always be false, maybe because of poncle's TP3 settings.
     * @property {false}      trimmed          This appears to always be false, maybe because of poncle's TP3 settings.
     * @property {Tp3Size}    sourceSize       The dimensions of the original image.
     * @property {Tp3SizePos} spriteSourceSize The dimensions and position of the image within the original file.
     * @property {Tp3SizePos} frame            The dimensions and position of the image within the sprite.
     */

    /**
     * @typedef {Object} Tp3Sprite Texture Packer 3 data describing a sprite.
     * @property {string}     image  The sprite's filename.
     * @property {string}     format The color format of the file.
     * @property {Tp3Size}    size   The total sprite dimensions.
     * @property {number}     scale  The scale sprite scale. Appears to always be 1, as would be expected for pixel art.
     * @property {Tp3Frame[]} frames Data describing the individual images packed within the sprite.
     */

    /**
     * @typedef {Object} Tp3Size Texture Packer 3 data describing an image's dimensions.
     * @property {number} w The image's width.
     * @property {number} h The image's height.
     */

    /**
     * @typedef {Object} Tp3SizePos Texture Packer 3 data describing an image's dimensions and position in the sprite.
     * @property {number} x The image's horizontal offset from the top-left point.
     * @property {number} y The image's vertical offset from the top-left point.
     * @property {number} w The image's width.
     * @property {number} h The image's height.
     */

    /** @typedef {string} VsImgFilename A Vampire Survivors image name, which is packed within a sprite. */

    /** @typedef {string} VsSprite A Vampire Survivors sprite's internal name. */

    /** @typedef {function} VsSpriteFunc A function that returns a Vampire Survivors sprite's internal name. */

    /** @typedef {string} VsSpriteName A Vampire Survivors sprite's name with title casing. */

    // ********************* //
    // ***** CONSTANTS ***** //
    // ********************* //

    // ------ //
    // PUBLIC //
    // ------ //

    /** @type {VsSpriteName} A custom sprite name that doesn't exist, to indicate to display images from all sprites. */
    this.ALL_SPRITES = 'All';

    // Constants to identify sprites. The constants' names are the name returned from this.getSpriteNames() in all
    // uppercase, and the values are their filenames without an extension.
    /** @type {VsSprite} */ this._MISSING      = '_MISSING';
    /** @type {VsSprite} */ this.ANGEL         = 'angel';
    /** @type {VsSprite} */ this.ARCANA        = 'randomazzo';
    /** @type {VsSprite} */ this.BACKGROUND_4  = 'background4';
    /** @type {VsSprite} */ this.BACKGROUND_6  = 'background6';
    /** @type {VsSprite} */ this.BACKGROUND_W  = 'backgroundW';
    /** @type {VsSprite} */ this.BACKGROUND_X  = 'backgroundX';
    /** @type {VsSprite} */ this.CHARACTERS    = 'characters';
    /** @type {VsSprite} */ this.ENEMIES       = 'enemies';
    /** @type {VsSprite} */ this.ENEMIES_2     = 'enemies2';
    /** @type {VsSprite} */ this.ENEMIES_3     = 'enemies3';
    /** @type {VsSprite} */ this.ENEMIES_M     = 'enemiesM';
    /** @type {VsSprite} */ this.ILLUSTRATIONS = 'illustrations';
    /** @type {VsSprite} */ this.ITEMS         = 'items';
    /** @type {VsSprite} */ this.SHOP          = 'shop';
    /** @type {VsSprite} */ this.UI            = 'UI';
    /** @type {VsSprite} */ this.VFX           = 'vfx';

    // DLC-specific sprites.

    // ------- //
    // PRIVATE //
    // ------- //

    /** @type {number} How many MS for each animation frame. */
    const ANIMATION_SPEED_MS = 150;

    /** @type {number} The default 1-base scale at which images should be displayed. */
    const DEFAULT_DISPLAY_SCALE = 2;

    /** @type {Object<VsSprite, DlcId>} A sparse map of sprites to their associated DLC, if they have one. */
    const SPRITE_DLC = {
    };

    // ********************* //
    // ***** VARIABLES ***** //
    // ********************* //

    /** @type {Object} Private object-scope variables. */
    const my = {
        /** @type {Object.<VsSprite, TexturePacker3Data|null>} A map of sprite filenames to data; null when loading. */
        cache: {},

        /** @type {Object.<VsSprite, function[]>} A map of sprite filenames to callbacks to trigger when loaded. */
        callbacks: {},

        /** @type {Object.<VsSprite, number>} A map of sprite filenames to animation frame request IDs. */
        callbackExecutionRequests: {},
    };

    // ********************* //
    // ***** FUNCTIONS ***** //
    // ********************* //

    // ------ //
    // PUBLIC //
    // ------ //

    /**
     * Creates and returns an element to display a Vampire Survivors image via a sprite.
     *
     * @param {VsSprite|VsSpriteFunc} sprite
     * @param {VsImgFilename}         filename
     * @param {number}                [scale]    The 1-base scale at which images should be displayed. Defaults to 2.
     * @param {function}              [callback] When specified, a callback that is called with the image element.
     * @return {HTMLSpanElement}
     */
    this.createImage = function (sprite, filename, scale, callback) {
        let image = DOM.ce('span', {className: 'vs-sprite-image'});
        displayImage(sprite, filename, image, scale, callback);

        return image;
    };

    /**
     * Creates and returns an element to display a Vampire Survivors image via a sprite.
     *
     * @param {VsSprite}        sprite
     * @param {VsImgFilename[]} filenames  The filenames of the frames that are a part of this animation.
     * @param {number}          [scale]    The 1-base scale at which images should be displayed. Defaults to 2.
     * @param {function}        [callback] When specified, a callback that is called with the image element.
     * @return {HTMLSpanElement}
     */
    this.createImageAnimated = function (sprite, filenames, scale, callback) {
        let imageWrapper = DOM.ce('span', {className: 'vs-sprite-image-wrapper'});
        let image = DOM.ce('span', {className: 'vs-sprite-image'}, imageWrapper);
        if (filenames.length === 1) {
            displayImage(sprite, filenames[0], image, scale, callback);
        } else {
            displayImage(sprite, filenames[0], image, scale, image => {
                let maxHeight = 0;
                let maxWidth = 0;
                getFramesData(sprite, filenames).forEach(/** @param {Tp3Frame} frame */ frame => {
                    maxHeight = Math.max(maxHeight, frame.frame.h);
                    maxWidth = Math.max(maxWidth, frame.frame.w);
                });

                maxHeight *= typeof scale === 'number' ? scale : DEFAULT_DISPLAY_SCALE;
                maxWidth *= typeof scale === 'number' ? scale : DEFAULT_DISPLAY_SCALE;

                imageWrapper.style.height = maxHeight + 'px';
                imageWrapper.style.width = maxWidth + 'px';

                let i = 0;
                let interval = setInterval(() => {
                    // Display the next image in the animation.
                    i++;
                    if (i + 1 > filenames.length) {
                        i = 0;
                    }
                    displayImage(sprite, filenames[i], image, scale, callback);
                }, ANIMATION_SPEED_MS);

                // When we change to another page, we need to stop the code from trying to update the animations.
                VST.Page.onLeavePage(() => clearInterval(interval));

                if (callback) {
                    callback(image);
                }
            });
        }

        return imageWrapper;
    };

    /**
     * Fills the main wrapper with all images, with a heading for each type.
     *
     * @param {string} [subPath] A sub-path that maps to an image sprite to display. Defaults to all sprites.
     * @param {number} [scale]   The 1-base scale at which images should be displayed. Defaults to 2.
     */
    this.displayAllImages = function (subPath, scale) {
        document.querySelector('h1').innerText = 'Vampire Survivors Images';

        let container = VST.Page.getContainer();

        if (typeof scale !== 'number') {
            scale = 3;
        } else if (scale > 4) {
            alert('Warning: At scales higher than 4 images will start to be too large to fit in the main container.');
        }

        getSpritesFromSubPath(subPath).forEach(spriteName => {
            let sprite = getSpriteBasenameFromName(spriteName);

            let imagesContainer = DOM.ce('div', undefined, container);
            DOM.ce('h2', undefined, imagesContainer, DOM.ct(spriteName));

            self.getFilenames(sprite, filenames => {
                filenames.sort((a, b) => a.localeCompare(b));
                filenames.forEach(filename => {
                    let imageContainer = DOM.ce('span', {style: {
                        display: 'inline-block',
                        margin: `${scale}px`,
                        textAlign: 'center',
                    }}, imagesContainer);

                    /** @type {HTMLDivElement} */
                    let title = DOM.ce('div', {style: {
                        boxSizing: 'border-box',
                        fontSize: '10px',
                        overflow: 'hidden',
                        padding: '0 2px',
                        textOverflow: 'ellipsis',
                    }}, imageContainer, DOM.ct(filename));

                    imageContainer.appendChild(self.createImage(sprite, filename, scale, image => {
                        title.style.width = parseInt(image.style.width) < 35 ? '35px' : image.style.width;

                        if (title.scrollWidth > title.clientWidth) {
                            imageContainer.title = filename;
                        }
                    }));

                    imageContainer.appendChild(title);
                });
            });
        });
    };

    /**
     * Fills the main wrapper with all images, with a heading for each type, and animates all that appear to have
     * animations.
     *
     * @param {string} [subPath] A sub-path that maps to an image sprite to display. Defaults to all sprites.
     * @param {number} [scale]   The 1-base scale at which images should be displayed. Defaults to 2.
     */
    this.displayAllImagesAnimated = function (subPath, scale) {
        document.querySelector('h1').innerText = 'Vampire Survivors Images Animated';

        let container = VST.Page.getContainer();

        if (typeof scale !== 'number') {
            scale = 3;
        } else if (scale > 4) {
            alert('Warning: At scales higher than 4 images will start to be too large to fit in the main container.');
        }

        getSpritesFromSubPath(subPath).forEach(spriteName => {
            let sprite = getSpriteBasenameFromName(spriteName);

            let imagesContainer = DOM.ce('div', undefined, container);
            DOM.ce('h2', undefined, imagesContainer, DOM.ct(spriteName));

            let animationFrameFilenames = {};

            self.getFilenames(sprite, filenames => {
                filenames.sort((a, b) => a.localeCompare(b));
                filenames.forEach(filename => {
                    let number = '0';
                    let groupName = filename;
                    let match = filename.match(/(.*\D|^)(\d+)(\D*\..*)/);
                    if (match) {
                        number = match[2];
                        groupName = match[1] + '#' + match[3];
                    }

                    if (!animationFrameFilenames[groupName]) {
                        animationFrameFilenames[groupName] = [];
                    }
                    animationFrameFilenames[groupName].push({
                        number: parseInt(number),
                        filename: filename,
                    });
                });

                Object.entries(animationFrameFilenames).forEach(([groupName, files]) => {
                    files.sort((a, b) => a.number - b.number);

                    let imageContainer = DOM.ce('span', {style: {
                            display: 'inline-block',
                            margin: `${scale}px`,
                            textAlign: 'center',
                        }}, imagesContainer);

                    /** @type {HTMLDivElement} */
                    let title = DOM.ce('div', {style: {
                            boxSizing: 'border-box',
                            fontSize: '10px',
                            overflow: 'hidden',
                            padding: '0 2px',
                            textOverflow: 'ellipsis',
                        }}, imageContainer, DOM.ct(groupName));

                    /** @type {VsImgFilename[]} */
                    let animationFrames = []
                    files.forEach(file => {
                        animationFrames.push(file.filename);
                    });

                    imageContainer.appendChild(self.createImageAnimated(sprite, animationFrames, scale, image => {
                        if (image.parentNode.style.width) {
                            image = image.parentNode;
                        }
                        title.style.width = parseInt(image.style.width) < 35 ? '35px' : image.style.width;

                        if (!imageContainer.title && title.scrollWidth > title.clientWidth) {
                            imageContainer.title = groupName;
                        }
                    }));

                    imageContainer.appendChild(title);
                });
            });
        });
    };

    /**
     * Delivers a list of filenames found in the given sprite to the given callback.
     *
     * @param {VsSprite} sprite
     * @param {function} callback
     */
    this.getFilenames = function (sprite, callback) {
        loadData(sprite, data => {
            let filenames = [];

            data.textures.forEach(tp3Sprite => {
                tp3Sprite.frames.forEach(frame => filenames.push(frame.filename));
            });

            callback(filenames);
        });
    };

    /**
     * Returns a list of all sprite names, which means the sprite filenames with title casing.
     *
     * @return {VsSpriteName[]}
     */
    this.getSpriteNames = () => {
        return [
            '_MISSING',
            'Angel',
            'Arcana',
            'Background 4',
            'Background 6',
            'Background W',
            'Background X',
            'Characters',
            'Enemies',
            'Enemies 2',
            'Enemies 3',
            'Enemies M',
            'Illustrations',
            'Items',
            'Shop',
            'UI',
            'VFX',
        ];
    };

    // ------- //
    // PRIVATE //
    // ------- //

    /**
     * Displays the requested image in the given <img> tag.
     *
     * @param {VsSprite|VsSpriteFunc} sprite
     * @param {VsImgFilename}         filename
     * @param {HTMLSpanElement}       target
     * @param {number}                [scale]    The 1-base scale at which images should be displayed. Defaults to 2.
     * @param {function}              [callback] When specified, a callback that is called with the image element.
     */
    function displayImage(sprite, filename, target, scale, callback) {
        if (typeof scale !== 'number') {
            scale = DEFAULT_DISPLAY_SCALE;
        }

        if (typeof sprite === 'function') {
            sprite = sprite();
        }

        loadData(sprite, /** @param {TexturePacker3Data} data */ data => {
            let success = data.textures.some(tp3Sprite => {
                scale *= tp3Sprite.scale;

                return tp3Sprite.frames.some(frame => {
                    if (frame.filename === filename) {
                        let sizePos = frame.frame;
                        let bgSizeScale = (tp3Sprite.size.w / sizePos.w) * 100;
                        Util.copyProperties(target.style, {
                            backgroundImage: `url(${getSpritePath(sprite, 'png')})`,
                            backgroundPosition: `-${scale * sizePos.x}px -${scale * sizePos.y}px`,
                            backgroundSize: `${bgSizeScale}% auto`,
                            height: `${scale * sizePos.h}px`,
                            width: `${scale * sizePos.w}px`,
                        });

                        if (callback) {
                            callback(target);
                        }

                        return true;
                    }
                });
            });

            if (!success) {
                VST.warn(`Could not load image filename [${filename}] from sprite [${sprite}].`);
            }
        });
    }

    /**
     * Executes all callbacks waiting for the given sprite.
     *
     * @param {VsSprite} sprite
     */
    function executeCallbacks(sprite) {
        delete my.callbackExecutionRequests[sprite];
        while (my.callbacks[sprite].length) {
            my.callbacks[sprite].shift()(my.cache[sprite]);
        }
    }

    /**
     * Returns the sprite basename from the given sprite name.
     *
     * @param {VsSpriteName} spriteName
     * @return {VsSprite}
     */
    function getSpriteBasenameFromName(spriteName) {
        return self[spriteName.toUpperCase().replace(' ', '_')];
    }

    /**
     * Returns a list of sprites to display from the given sub-path. Falls back on all sprites.
     *
     * @param {string} [subPath]
     * @return {VsSpriteName[]}
     */
    function getSpritesFromSubPath(subPath) {
        let allSprites = self.getSpriteNames();

        if (subPath) {
            let slug = Util.slug(subPath);

            let sprite;
            allSprites.some(spriteName => {
                if (Util.slug(spriteName) === slug) {
                    sprite = spriteName;

                    return true;
                }
            });

            if (sprite) {
                return [sprite];
            }
        }

        return allSprites;
    }

    /**
     * Returns data on multiple frames from the given filenames.
     *
     * @param {VsSprite}        sprite
     * @param {VsImgFilename[]} filenames
     * @return {Tp3Frame[]}
     */
    function getFramesData(sprite, filenames) {
        let framesData = [];

        my.cache[sprite].textures.forEach(tp3Sprite => {
            tp3Sprite.frames.forEach(frame => {
                if (filenames.includes(frame.filename)) {
                    framesData.push(frame);
                }
            });
        });

        return framesData;
    }

    /**
     * Returns the path to a sprite with the given extension.
     *
     * @param {VsSprite} sprite
     * @param {string}   extension
     * @return {string} A path to the given sprite, relative to the tool's root.
     */
    function getSpritePath(sprite, extension) {
        return `${VS.getAssetsPath(SPRITE_DLC[sprite])}/img/${sprite}.${extension}`;
    }

    /**
     * Loads the image data as needed, and then calls the callback.
     *
     * Even if the data is immediately available, the callback is always called asynchronously, so that bugs are not
     * introduced by an inconsistent result.
     *
     * @param {VsSprite} sprite
     * @param {function} callback
     */
    function loadData(sprite, callback) {
        if (!my.callbacks[sprite]) {
            my.callbacks[sprite] = [];
        }
        my.callbacks[sprite].push(callback);

        if (my.cache[sprite] === undefined) {
            // Load the data, then execute callbacks for this sprite.
            fetch(getSpritePath(sprite, 'json')).then(response => {
                response.json().then(data => {
                    my.cache[sprite] = data;
                    executeCallbacks(sprite);
                });
            });
        } else if (my.cache[sprite]) {
            // Register a request to execute callbacks for this sprite.
            if (!my.callbackExecutionRequests[sprite]) {
                my.callbackExecutionRequests[sprite] = requestAnimationFrame(() => executeCallbacks(sprite));
            }
        }
    }
};
